This project is an attempt to create some sort of parser for boost test. So instead of having some horrendous command line output, a developer could have something a little easier on the eyes.

I should mention that I'm trying to design it so that the program can work with any test framework. One would just have to switch out for a different parser and runner. 

As of writing, I'm focusing on the parsing and not on the display aspect. I plan to design it in such a way that the display module can be held separate from the parsing, and therefore be interchanged with whatever the user wants to use. The two things that spring to mind are plain OOP and Strategy Pattern.

I should mention that this is my first Python project (serious coding with an final application in mind.) I've worked heavily in C++, so assume that I'll make mistakes similar to anyone whose not sure how to do something in a new language (i.e: do something un-pythonic). In particular the use of packages in python (why the init.py?) I've used Java in college, so I'll assume Python's package system serves a similar purpose and functions in a similar fashion.

Also, please give feedback. If you find something that bugs you enough to complain about it, its important enough to send me an email. Same goes for positive aspects as well. If I get no feedback, I have no clue how well this software functions in the user's perspective. As a developer, I can't function as a true user b/c I know too much about how it functions and therefore know how to get it to work.

Matthew A. Todd


Design using MVC pattern:
 	- model
 		- contains an object which allows to rerun tests
 			- think Alleyoop
		- parsing
	- displaying
		- COLORS!!!
		- show/hide tests and other information

----------------------------

Road Map:

From this moment,there are several ways to proceed: 
 Display:
 	because we're using MVC, and thus strategies, we can build up our designs w/o getting rid of old ones.
 	- console display
 		- not going to be much different that Boost::Test's original output. But its a good start. Plus it can be useful and we can make it look better if we want.
 	- simple gui
 		- simple as in it displays the output with some colors, but doesn't interact with user. This means we don't need much of an controller
 	- interactive gui
 		- same as simple, but accepts user interaction. I.e: swap in a different controller.
 			- directory tree structure for tests
 				- open and close certain directories, hiding test we aren't interested in.
 			- rerun tests?
 				- this would require executing a process
 					- need a reference to the test runner
* 						- we could make our gui wrap the test runner. So instead of just parsing output, it can run the tests. E.g: Alleyoop

Views:
Here are the order of views to build. Do text first, then build a Gui.
Text:
1) just display result

Gui:
1) just display data
2) allow user to hide/show data
	- most likely just part of Gui framework. We won't need to implement a controller for this.
3) allow user to interact with test runner
	- run all tests
	- run certain tests

	
	
Program Options
 - test runner:
 	- assigns/selects the test runner
 	- should go ahead and automatically run, parse, and display
 - specific tests/suites:
 	- run specific tests on startup
 	- only valid if test runner selected
 		possibile ways to handle
 		- check
 		- let run_() throw
 			- catch print move on 	
 - xml file:
	- open up an xml file to parse and display

	
It would be nice if the GUI could run arbitrary Python scripts. The idea being that an user could run a script which compiles the test runner then calls run on it. I'm assumming we're going to want to pass in something into it the script call so that scripts will have a reference to some of the data. Possibly the model (which would use Observer pattern to notify the display should the script change the model's data somehow.) I guess a question is whether the script would ever want to do something to the gui. I suppose its possible, so we should allow for it, meaning we need to give a reference to the Gui as well. If we have a containing class which contains all the particpating objects in the running program, it would be a good option to pass in. 
